# 부동소수점

  일단, 부동소수점이 무엇인지에 대한 설명이 필요하다.
  바로 컴퓨터에서 실수를 표현하기 위해서 사용되는 방식인데, 이진수 밖에 모르는 컴퓨터는 소수를 이진수로 표현해내야 한다.
  IEEE754라고 도 하며 이것은 `bias64(-63~64)`, `bias 127(-126~127)`, `bias1023(-1022~1023)`로 나타낼 수가 있다.

## 단정도 bias64

- 십진수 `13.75`를 이진수로 표현하면 다음과 같다.

  - `1101.11(2) = 1.10111 * 2^3`, 2의 3승에서의 3을 64와 더한다. 1은 똑같으므로 저장하지 않는다.

- 부호부 (1비트) : 양수일 때는 0, 음수일 때는 1
- 지수부 (7비트) : 나머지 7비트로 표시
- 정규화된 가수부 (부호가 없는 정수, 24비트) : 제일 앞의 비트는 정규화되었으므로 1이다.

- 부호부는 해당 수가 양수이므로 `0`
- 지수부는 `64+3 = 67` 로, `0100011`
- 정규화된 가수부는 `101110000000000000000000`이 된다.
- 최종적으로 `0 0100011.101110000000000000000000`으로 표현이 된다.

- `2^-64 ~ 2^63` 까지 표현 가능.

## 단정도 bias127 (float - 4byte)

- 십진수 `-0.5625`를 이진수로 표현하면 다음과 같다.

  - `-0.1001(2) = 1.001 * 2^(-1)`, 2의 -1승에서의 -1을 127과 더한다.

- 부호부 (1비트) : 양수일 때는 0, 음수일 때는 1
- 지수부 (8비트) : 나머지 8비트로 표시
- 정규화된 가수부 (부호가 없는 정수, 23비트) : 제일 앞의 비트는 정규화되었으므로 1이다.

- 부호부는 해당 수가 음수이므로 `1`
- 지수부는 `127+(-1) = 126` 으로, `01111111`
- 정규화된 가수부는 `00100000000000000000000`으로 표현이 된다.
- 최종적으로 `1 01111111.00100000000000000000000`으로 표현이 된다.

- `1.175494351E-38 ~ 3.402823466E+38`, 정밀도 7자리

## 배정도 bias1023 (double - 8byte)

- 십진수 `1024.75` 를 이진수로 표현하면 다음과 같다.

  - `10000000000.11(2) = 1.000000000011 * 2^10`, 2의 10승에서 10을 1023과 더한다.

- 부호부 (1비트) : 양수일 때는 0, 음수일 때는 1
- 지수부 (11비트) : 나머지 11비트로 표시
- 정규화된 가수부 (부호가 없는 정수, 52비트) : 제일 앞의 비트는 정규화되었으므로 1이다.

- 부호부는 해당 수가 양수이므로 `0`
- 지수부는 `1023+10 = 1023+9 = 1023+8+1 = 1033`, `10000001001`
- 가수부는 `000000000011000000000000000000000000000000000000000`
- 최종적으로 `0 10000001001.000000000011000000000000000000000000000000000000000`

- `2.2250738585072014E-308 ~ 1.7976931348623158E+308`, 정밀도 15자리

### 위키에서 설명한 내용

<img src="https://github.com/Geol2/Today-I-Learned/blob/main/CS/images/bias.png">

- 단정도 정밀도는 Bias 127
- 배정도 정밀도는 Bias 1023
- 4배정도(?) 정밀도는 Bias 16383

### 수학적 표기법

$$x = \pm (.1b_2b_3...b_k) \times 2^e$$

- 이 부동소수점 `x`는 정규화 되었다고 한다.
- 가수부
  $$(.1b_2b_3...b_k)$$
- 지수부
  - `e`

### 그래서 하고싶은 말이 뭔데? 정밀도에 대한 문제

- 이러한 연산 기법들은 프로그램에서 `float`, `double`, `long float`와 같은 부동소수점 자료형이나 아주 큰 수에서 정확도에 문제가 발생된다.
- 왜냐하면 소수를 이진수로 표현할 방법이 없기 때문에 부동소수점 표기법을 사용해서 오차범위 내에서 그냥 반올림해버리기 때문에 근사값만 `return` 해줘버리기 때문이다.
- C++ 에서는 `std::setprecision()` 에서 출력스트림에 대한 소수점 자리수 설정이 가능하다. `cout` 인 출력 스트림에서 사용이 되지만, 실제 해당 데이터에선 자리수 설정이 안됨을 참고하자
- JAVA 에서는 `BigDecimal`을 사용해야한다.

<img src="https://github.com/Geol2/Today-I-Learned/blob/main/CS/images/precision.png">


- 정수단위 값의 범위도 그렇지만 소수점에서 얼마나 더 정밀하게 오차없이 표현할 수 있냐의 차이라고 볼 수 있다.
- `float`에선 소수점 7자리까지의 정밀도
- `double`에선 소수점 16자리까지의 정밀도

- 다음 아래의 예제 코드를 보자.

```c++
#include <stdio.h>
#include <math.h>
using namespace std;

int main() {
    float n = 0.1;
    printf("%.10f\n", n);
    return 0;
}

// 0.1000000015
```

### 오류코드

```c++
#include <iostream>
#include <math.h>

int main() {
long long a;
std::cin >> a;
long long s = 0;
long long e = sqrt(a);
long long mid;

    while (s <= e) {
        mid = (s + e) / 2;
        if (mid >= sqrt(a)) e = mid - 1;
        else s = mid + 1;
    }

    if (mid * mid == a) std::cout << mid << std::endl;
    else std::cout << mid + 1 << std::endl;

}

// 땡.
```

### 재통과 코드

```c++
#include <iostream>
#include <math.h>
using namespace std;

int main() {
    long long n;
    long long q;
    cin >> n; q = sqrt(n);
    if ( (q*q) < n) { ++q; }
    cout << q;
    return 0;
}

// 통과
```

-----

[2417 정수제곱근(부동소수점)](https://geol2.github.io/baekjoon/algorithm/2417/)