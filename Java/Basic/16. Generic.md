# 다형성을 통한 중복 해결 시도

`Object`를 통해 다형성을 활용한 덕분에 코드의 중복을 제거하고 기존 코드를 재활용할 수 있다.

하지만 그로인한 타입 안정성에 문제가 생길 수 있다.

예를 들어서 `IntergerBox`에는 숫자만 넣을 수 있고 `StringBox`에는 문자열만 입력할 수 있어야 한다. 하지만 값을 보관하는 `set()` 의 파라미터 타입이 `Object` 이기 때문에 다른 타입의 값을 입력할 수 있다. 반환 시점도 `Object`를 반환하기 때문에 원하는 타입을 정확하게 받아올 수 없고, 위험한 다운 캐스팅을 시도해야하는 문제가 있다.

```java
public class GenericBox<T> {

    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}

public class BoxMain3 {

    public static void main(String[] args) {
        GenericBox<Integer> integerBox = new GenericBox<Integer>(); //생성 시점에 T의 타입 결정
        integerBox.set(10);
        //integerBox.set("문자100"); // Integer 타입만 허용, 컴파일 오류
        Integer integer = integerBox.get(); // Integer 타입 반환 (캐스팅 X)
        System.out.println("integer = " + integer);

        GenericBox<String> stringBox = new GenericBox<String>();
        stringBox.set("hello"); // String 타입만 허용
        String str = stringBox.get(); // String 타입만 반환
        System.out.println("str = " + str);

        //원하는 모든 타입 사용 가능
        GenericBox<Double> doubleBox = new GenericBox<Double>();
        doubleBox.set(10.5);
        Double doubleValue = doubleBox.get();
        System.out.println("doubleValue = " + doubleValue);

        //타입 추론: 생성하는 제네릭 타입 생략 가능
        GenericBox<Integer> integerBox2 = new GenericBox<>(); // 타입 추론:     
    }
}
```

- 타입 추론 : 생성하는 제네릭 타입을 생략, `new GenericBox<>()` 처럼 다이아몬드 사이에 공백을 둬서 생략이 가능하다.

# Generic

타입 형변환에서 발생할 수 있는 문제점을 사전에(컴파일) 없애기 위해서 만들어짐

`<>` 보통 다이아몬드라고 불리고 제네릭 클래스라고 불린다

사용할 타입을 미리 결정하지 않는다

- 장점 : 코드 재사용과 타입 안정성을 모두 잡을 수 있다


```java
public class CastingGenericDTO<T> implements Serializable {
    
    private T object;

    public void setObject(T obj) {
        this.object = obj;
    }
    
    public T getObject() {
        return object;
    }
}
```

클래스 이름에 꺽쇠를 사용하면 되고 `T` 는 타입을 의미한다.

`T`를 타입 매개변수라고 불린다

- `E` : 요소
- `K` : 키
- `N` : 숫자
- `T` : 타입
- `V` : 값
- `S`, `U`, `V` : 두 번째, 세 번째, 네 번째에 선언된 타입
- `?` : 명시적으로 지정하기 애매할 때 적는다
- `? extends 타입` : 명시적으로 지정하기는 애매하지만, 클래스의 상속을 받은 특정 타입만 가능하다는 것을 나타냄

## 타입 매개변수 제한

```java
public class AnimalHospitalV2<T> {
    
    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkup() {
        animal.toString();
        animal.equals(null);
    }

    public T getBigger(T target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```

`T` 타입에 모든 타입이 올 수 있다.

`AnimalHospitalV2<Dog> dogHospital = new AnimalHospitalV2<>()`, `AnimalHospitalV2<Cat> dogHospital = new AnimalHospitalV2<>()` 만 오고 싶은데 `Integer`, `Double` 등등 모두 올 수 있는 단점이 있다.

`Animal`과 그 자식 클래스에만 제한을 거는 방법은 아래와 같다.

```java
public class AnimalHospitalV3<T extends Animal> {
    
    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkup() {
        animal.toString();
        animal.equals(null);
    }

    public T getBigger(T target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```

## 제네릭 메서드

```java
public class GenericMethod {

    public static Object objMethod(Object obj) {
        System.out.println("Object print : " + obj);
        return obj;
    }

    public static <T> T genericMethod(T t) {
        System.out.println("Object print : " + t);
        return t;
    }

    public static <T extends Number> T numberMethod(T t) {
        System.out.println("bound print : " + t);
        return t;
    }
}

public class MethodMain1 {
    public static void main(String[] args) {
        Integer i = 10;
        Object object = (Integer) GenericMethod.dobjMethod(i);

        System.out.println("명시적 타입 인자 전달");
        Integer result = GenericMethod.<Integer>genericMethod(i);
        Integer integerValue = GenericMethod.<Integer>numberMethod(10);
        Double doubleValue = GenericMethod.<Double>numberMethod(20.0);

        // 결과
        // Obect print: 10
        // 명시적 타입 인자 전달
        // generic print: 10
        // bound print: 10
        // bound print: 20

        // 타입추론 가능
        Integer result2 = GenericMethod.genericMethod(i);
        Integer integerValue2 = GenericMethod.numberMethod(10);
        Double doubleValue2 = GenericMethod.numberMethod(20.0);
        
    }
}
```

## 상한 와일드카드

```java
static <T extends Animal> void printGenericV2(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
}

static void printWildcardV2(Box<? extends Animal> box) {
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
}
```

와일드카드에도 상한 제한을 둘 수 있다.

`? extends Animal`로 `Animal`과 그 하위타입만 입력 받을 수 있고 다른 타입 입력 시, 컴파일 오류가 발생한다.

`box.get()`을 통해 최대 부모는 Animal이 된다.