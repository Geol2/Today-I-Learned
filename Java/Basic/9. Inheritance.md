# 상속

최상위 클래스인 Object 클래스가 존재함

자식 클래스는 선언 시, extends 다음에 부모 클래스 이름을 사용

자식 클래스 생성자가 호출되면 자동으로 부모 클래스의 기본 생성자가 호출

기본 생성자없이 다른 생성자가 있으면 에러
  - 부모 클래스에 매개변수가 없는 기본 생성자를 만듦
  - 자식 클래스에 `super()`를 사용해서 부모 클래스의 생성자를 명시적으로 지정

자식 클래스에서는 부모 클래스에 있는 public, protected로 선언된 인스턴스 변수 및 클래스 변수와 메소드를 사용

자식 클래스와 부모 클래스의 공통적인 메서드는 부모 클래스에 만들어두고 사용

## 표현

<img src="./images/Inheritance-1.png" width="150">

## 메소드 오버라이딩

자식 클래스에서 부모 클래스의 메소드의 이름을 동일하게 선언

접근 제어자, 리턴 타입, 메소드 이름, 매개 변수 타입 및 개수가 모두 동일해야함

## 다형성

형변환을 하더라도 원래 객체의 메서드를 실행함

## 실습 작성
```java
// Animal.java
public class Animal {
    public String name;

    public String kind;

    public int legCount = 4;

    public int iq;

    public boolean hasWing = false;

    public Animal() {
        System.out.println("Animal Constructor");
    }

    public Animal(String name, String kind, int iq) {
        this.name = name;
        this.kind = kind;
        this.iq = iq;
    }

    public void move(){
        System.out.println("Animal move");
    }

    public void eatFood() {
        System.out.println("Animal eatFood");
    }

    public void sound() {
        System.out.println("Animal sound");
    }

    public String toString() {
        System.out.println( name + " " + kind + " " + legCount + " " + iq + " " + hasWing );
        return name + " " + kind + " " + legCount + " " + iq + " " + hasWing;
    }
}
```

```java
// Cat.java
public class Cat extends Animal {

    public Cat() {
        super("cat", "african wildcat", 50);
        System.out.println("Cat Constructor");
    }

    public void eatFood() {
        System.out.println("고양이 밥먹기");
    }

    public void sound() {
        System.out.println("고양이 냐옹");
    }
}

```

```java
public class Dog extends Animal {

    public Dog() {
        super("dog", "gray wolf", 60);
        System.out.println("Dog Constructor");
    }

    public void eatFood() {
        System.out.println("멍멍이 밥먹기");
    }

    public void sound() {
        System.out.println("멍멍이 왈왈");
    }

    public void move() {
        System.out.println("멍멍이 걷기");
    }
}

```

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        animal.eatFood();
        animal.sound();

        Animal cat = new Cat();
        cat.eatFood();
        cat.sound();
        cat.move();

        Animal dog = new Dog();
        dog.eatFood();
        dog.sound();
        dog.move();
    }
}
```

```
Animal Constructor
Animal eatFood
Animal sound
Cat Constructor
고양이 밥먹기
고양이 냐옹
Animal move
cat african wildcat 4 50 false
Dog Constructor
멍멍이 밥먹기
멍멍이 왈왈
멍멍이 걷기
dog gray wolf 4 60 false
```

- `javac Animal.java Dog.java Cat.java Main.java`

- `java Main.java`


# 모든 클래스의 부모인 java.lang.Object 클래스

## Object 클래스에서 제공하는 메소드의 종류

- `protected Object clone()` : 객체의 복사본을 생성하고 리턴

- `public boolean equals(Object obj)` : 현재 객체와 매개 변수로 넘겨받은 객체가 같은지 확인. 같으면 true, 다르면 false를 리턴

- `protected void finalize()` : 현재 객체가 더 이상 쓸모가 없어졌을 때 가비지 컬렉터에 의해서 이 메소드가 호출된다.

- `public class<?> getClass()` : 현재 객체의 Class 클래스의 객체를 리턴한다.

- `public int hashCode()` : 객체에 대한 해시 코드 값을 리턴한다.

- `public String toString()` : 객체를 문자열로 표현하는 값을 표현한다.

## 쓰레드 처리를위한 메소드의 종류

- `public void notify()` : 이 객체의 모니터에 대기하고 있는 단일 쓰레드를 깨운다.

- `public void notifyAll()` : 이 객체의 모니터에 대기하고 있는 모든 쓰레드를 깨운다.

- `public void wait()` : 다른 쓰레드가 현재 객체에 대한 notify() 메소드나 notifyAll() 메소드를 호출할 때까지 현재 쓰레드가 대기하고 있도록 한다.

- `public void wait(long timeout)` : 매개 변수에 지정한 시간만큼 대기했다가 넘으면 현재 쓰레드가 실행된다. 1초는 1000m/s 이다.

- `public void wait(long timeout, int nanos)` :  매개변수에 밀리초, 나노초 만큼만 대기한다.

## toString()

해당 클래스가 어떤 객체인지 쉽게 나타낼 수 있는 중요한 메서드

이 메소드가 자동으로 호출되는 경우는 다음과 같다.

- `System.out.println()` 메소드에 매개 변수로 들어가는 경우

- 객체에 대하여 더하기 연산을 하는 경우

```java

class Student {
    String name, address, phone, email;

    public Student(String name) {
        this.name = name;
    }

    public Student(String name, String address, String phone, String email) {
        this.name = name;
        this.address = address;
        this.phone = phone;
        this.email = email;
    }

    public String toString() {
        return name + " " + address + " " + phone + " " + email;
    }

    public boolean equals(Object obj) {
        if(this == obj) return true;
        if(obj == null) return false;
        if(getClass() != obj.getClass()) return false;

        Student other = (Student) obj;
        if(address == null) {
            if(other.address != null) return false;
        } else if( !address.equals(other.address) ) {
            if( other.email != null ) return false;
        }

        if(name == null) {
            if(other.name != null) return false;
        } else if( !name.equals(other.name) ) return false;

        if(phone == null) {
            if( other.phone != null ) return false;
        } else if(!phone.equals(other.phone)) return false;

        return true;
    }
}

public class StudentManager {
    public Student[] addStudent() {
        Student[] student = new Student[3];
        student[0] = new Student("Lim");
        student[1] = new Student("Min");
        student[2] = new Student("Sook", "Seoul", "010XXXXXXXX", "ask@godOfJava.com");
        return student;
    }

    public void printStudent(Student[] student) {
        for(Student data : student) {
            System.out.println(data.name + " " + data.address + " " + data.phone + " " + data.address);
        }
    }

    public void checkEquals() {
        Student a = new Student("Min", "Seoul", "010XXXXXXXX", "ask@godofjava.com");
        Student b = new Student("Min", "Seoul", "010XXXXXXXX", "ask@godofjava.com");

        if(a.equals(b)) {
            System.out.println("Equals");
        } else {
            System.out.println("Not Equals");
        }
    }
    
    public static void main(String[] args) {
        Student[] student = null;

        StudentManager studentManager = new StudentManager();
        // student = studentManager.addStudent();
        // studentManager.printStudent(student);
        studentManager.checkEquals();
    }
}
```
```
Equals
```